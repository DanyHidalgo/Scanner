// Paquete
package parser;

// Importaciones necesarias
import java_cup.runtime.*;
import ast.*; 
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;


// Declaraciones de símbolos (terminales)
terminal CLASS, ID, IF, ELSE, WHILE, RETURN, INT, BOOLEAN, FLOAT, VOID;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, ASSIGN, LESS_THAN, GREATER_THAN, LESS_THAN_EQUALS, GREATER_THAN_EQUALS, EQUALS_EQUALS, NOT_EQUALS, SEMICOLON;
terminal LPAREN, RPAREN, LBRACE, RBRACE, COMMA, INTLIT, FLOATLIT, STRINGLIT, TRUE, FALSE, ERROR, NUMBER, TIMES, NOT, AND, OR, BREAK, CONTINUE, CALLOUT;

// Declaraciones de no terminales
non terminal Program, FieldDecl, MethodDecl, Block, VarDecl, Type, FieldDecls, CalloutArgs, FieldDeclList;
non terminal Statement, Expr, Location, AssignOp, MethodCall, CalloutArg, MethodDecls;
non terminal BinOp, ArithOp, RelOp, EqOp, CondOp, Literal, Identifier, VarDecls;
non terminal FormalParameters, FormalParameter, MethodName, Alpha, Digit, AlphaNum, Statements;


// Precedencia
precedence right ELSE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence right NOT;
precedence left AND, OR;
precedence left LESS_THAN, GREATER_THAN, LESS_THAN_EQUALS, GREATER_THAN_EQUALS;
precedence left EQUALS_EQUALS, NOT_EQUALS;



// Regla inicial
start with Program;

Program ::= CLASS ID:id LBRACE FieldDecls:fd MethodDecls:md RBRACE
           {: 
               System.out.println("Program -> class Program { FieldDecls MethodDecls }");
               RESULT = new ProgramNode(id.toString(), fd, md);
           :}
           ;


FieldDecls ::= /* vacío */
             {: 
                 System.out.println("FieldDecls -> vacío");
                 RESULT = new FieldDeclsNode(new ArrayList<ASTNode>());
             :}
             | FieldDecls FieldDecl:fd
             {: 
                 System.out.println("FieldDecls -> FieldDecl FieldDecls");
                 ((FieldDeclsNode)RESULT).getFieldDecls().add(fd); 
             :}
             ;

FieldDeclList ::= FieldDecl:fd
                {: 
                    System.out.println("FieldDeclList -> FieldDecl");
                    RESULT = new FieldDeclListNode(Arrays.asList(fd)); 
                :}
                | FieldDeclList:fld FieldDecl:fd
                {: 
                    System.out.println("FieldDeclList -> FieldDeclList FieldDecl");
                    List<ASTNode> fieldDecls = new ArrayList<>(((FieldDeclListNode)fld).getFieldDecls());
                    fieldDecls.add(fd);
                    RESULT = new FieldDeclListNode(fieldDecls);
                :}
                ;


FieldDecl ::= Type:type ID:id SEMICOLON
            {: 
                System.out.println("FieldDecl -> Type ID ;");
                RESULT = new FieldDeclNode(type.toString(), id.toString());
            :}
            | Type:type ID:id LBRACE INTLIT:size RBRACE SEMICOLON
            {: 
                System.out.println("FieldDecl -> Type ID [INTLIT] ;");
                RESULT = new FieldDeclNode(type.toString(), id.toString(), new LiteralNode(size.toString()));
            :}
            ;


FormalParameters ::= /* vacío */
                   {: 
                       System.out.println("FormalParameters -> vacío");
                       RESULT = new FormalParametersNode(new ArrayList<ASTNode>());
                   :}
                   | FormalParameter:fp
                   {: 
                       System.out.println("FormalParameters -> FormalParameter");
                       RESULT = new FormalParametersNode(Arrays.asList(fp));
                   :}
                   | FormalParameters:fpList COMMA FormalParameter:fp
                   {: 
                       System.out.println("FormalParameters -> FormalParameters , FormalParameter");
                       List<ASTNode> params = new ArrayList<>(((FormalParametersNode)fpList).getFormalParameters());
                       params.add(fp);
                       RESULT = new FormalParametersNode(params);
                   :}
                   ;

// Para la regla FormalParameter
FormalParameter ::= Type:type ID:id
                  {: 
                      System.out.println("FormalParameter -> Type ID");
                      RESULT = new FormalParameterNode(type.toString(), id.toString());
                  :}
                  ;



// Para la regla MethodDecls
MethodDecls ::= MethodDecl:md
              {: 
                  System.out.println("MethodDecls -> MethodDecl");
                  RESULT = new MethodDeclsNode(Arrays.asList(md));
              :}
              | MethodDecls:mdList MethodDecl:md
              {: 
                  System.out.println("MethodDecls -> MethodDecls MethodDecl");
                  List<ASTNode> methods = new ArrayList<>(((MethodDeclsNode)mdList).getMethodDecls());
                  methods.add(md);
                  RESULT = new MethodDeclsNode(methods);
              :}
              ;

// Para la regla MethodDecl
MethodDecl ::= Type:type ID:id LPAREN FormalParameters:fp RPAREN Block:block
             {: 
                 System.out.println("MethodDecl -> Type ID (FormalParameters) Block");
                 RESULT = new MethodDeclNode(type.toString(), id.toString(), fp, block);
             :}
             | VOID:id ID:id LPAREN FormalParameters:fp RPAREN Block:block
             {: 
                 System.out.println("MethodDecl -> void ID (FormalParameters) Block");
                 RESULT = new MethodDeclNode("void", id.toString(), fp, block);
             :}
             ;


// Para la regla Block
Block ::= LBRACE VarDecls:v Statements:s RBRACE
        {: 
            System.out.println("Block -> { VarDecls Statements }");
            RESULT = new BlockNode(v, s);
        :}
        ;


VarDecls ::= /* empty */
           {: 
               System.out.println("VarDecls -> /* empty */");
               RESULT = new VarDeclsNode(new ArrayList<VarDeclNode>());
           :}
           | VarDecl:v VarDecls:vs
           {: 
               System.out.println("VarDecls -> VarDecl VarDecls");
               List<VarDeclNode> varDeclList = new ArrayList<>(((VarDeclsNode)vs).getVarDecls());
               varDeclList.add(v);
               RESULT = new VarDeclsNode(varDeclList);
           :}
           ;

VarDecl ::= Type:type ID:id SEMICOLON
          {: 
              System.out.println("VarDecl -> Type ID ;");
              RESULT = new VarDeclNode(type.toString(), id.toString());
          :}
          ;


Type ::= INT
       {: 
           System.out.println("Type -> INT");
           RESULT = new TypeNode("INT");
       :}
       | BOOLEAN
       {: 
           System.out.println("Type -> BOOLEAN");
           RESULT = new TypeNode("BOOLEAN");
       :}
       ;


// Para la regla Statements
Statements ::= Statement:s
             {: 
                 System.out.println("Statements -> Statement");
                 RESULT = new StatementsNode(java.util.Collections.singletonList(s));
             :}
             | Statements:ss Statement:s
             {: 
                 System.out.println("Statements -> Statements Statement");
                 List<StatementNode> stmtList = new java.util.ArrayList<>(((StatementsNode)ss).getStatements());
                 stmtList.add(s);
                 RESULT = new StatementsNode(stmtList);
             :}
             ;

// Para la regla Statement (y subreglas)
Statement ::= Location:l AssignOp:a Expr:e SEMICOLON
            {: 
                System.out.println("Asignación exitosa");
                RESULT = new AssignmentNode(l, a, e);
            :}
            | MethodCall:m SEMICOLON
            {: 
                System.out.println("Método llamado: " + m);
                RESULT = new MethodCallNode(m, new CalloutArgsNode());  // Llamada vacía para ahora
            :}
            | IF LPAREN Expr:cond RPAREN Block:b
            {: 
                System.out.println("If statement");
                RESULT = new IfNode(cond, b, null);
            :}
            | IF LPAREN Expr:cond RPAREN Block:b ELSE Block:e
            {: 
                System.out.println("If-Else statement");
                RESULT = new IfNode(cond, b, e);
            :}
            | WHILE LPAREN Expr:cond RPAREN Block:b
            {: 
                System.out.println("While statement");
                RESULT = new WhileNode(cond, b);
            :}
            | RETURN Expr:e SEMICOLON
            {: 
                System.out.println("Return statement");
                RESULT = new ReturnNode(e);
            :}
            | BREAK SEMICOLON
            {: 
                System.out.println("Break statement");
                RESULT = new BreakNode();
            :}
            | CONTINUE SEMICOLON
            {: 
                System.out.println("Continue statement");
                RESULT = new ContinueNode();
            :}
            | Block:b
            {: 
                System.out.println("Block statement");
                RESULT = b;
            :}
            ;


Location ::= ID:id
           {: 
               System.out.println("Location -> ID");
               RESULT = new LocationNode(id, null);  // Sin corchetes
           :}
           | ID:id LBRACE Expr:e RBRACE
           {: 
               System.out.println("Location -> ID [Expr]");
               RESULT = new LocationNode(id, e);  // Con corchetes
           :}
           ;


AssignOp ::= ASSIGN
           {: 
               System.out.println("AssignOp -> ASSIGN");
               RESULT = new AssignOpNode("ASSIGN");
           :}
           | TIMES
           {: 
               System.out.println("AssignOp -> TIMES");
               RESULT = new AssignOpNode("TIMES");
           :}
           | PLUS
           {: 
               System.out.println("AssignOp -> PLUS");
               RESULT = new AssignOpNode("PLUS");
           :}
           | MINUS
           {: 
               System.out.println("AssignOp -> MINUS");
               RESULT = new AssignOpNode("MINUS");
           :}
           ;


MethodCall ::= MethodName:m LPAREN CalloutArgs:ca RPAREN
             {: 
                 System.out.println("MethodCall -> MethodName (CalloutArgs)");
                 RESULT = new MethodCallNode(m, ca);  // Llamada a método con sus argumentos
             :}
             | CALLOUT LPAREN STRINGLIT:s CalloutArgs:ca RPAREN
             {: 
                 System.out.println("MethodCall -> CALLOUT (STRINGLIT CalloutArgs)");
                 RESULT = new MethodCallNode("CALLOUT " + s, ca);  // Llamada CALLOUT con argumentos
             :}
             ;

MethodName ::= ID:id
             {: 
                 System.out.println("MethodName -> ID");
                 RESULT = new MethodNameNode(id);  // Solo el nombre del método
             :}
             ;


CalloutArgs ::= /* empty */
              {: 
                  System.out.println("CalloutArgs -> empty");
                  RESULT = new CalloutArgsNode(new ArrayList<>());  // Lista vacía
              :}
              | CalloutArg:ca
              {: 
                  System.out.println("CalloutArgs -> CalloutArg");
                  List<CalloutArgNode> list = new ArrayList<>();
                  list.add(ca);  // Un solo argumento
                  RESULT = new CalloutArgsNode(list);
              :}
              | CalloutArgs:ca COMMA CalloutArg:arg
              {: 
                  System.out.println("CalloutArgs -> CalloutArgs COMMA CalloutArg");
                  List<CalloutArgNode> list = ((CalloutArgsNode) ca).getArgs();
                  list.add(arg);  // Agrega el nuevo argumento a la lista
                  RESULT = new CalloutArgsNode(list);
              :}
              ;

CalloutArg ::= Expr:e
             {: 
                 System.out.println("CalloutArg -> Expr");
                 RESULT = new CalloutArgNode(e);  // El argumento es una expresión
             :}
             ;

Expr ::= Location:l
       {: 
           System.out.println("Expr -> Location");
           RESULT = l;  // Location es una expresión
       :}
       | MethodCall:mc
       {: 
           System.out.println("Expr -> MethodCall");
           RESULT = mc;  // MethodCall es una expresión
       :}
       | Literal:l
       {: 
           System.out.println("Expr -> Literal");
           RESULT = l;  // Literal es una expresión
       :}
       | Expr:e1 PLUS Expr:e2
       {: 
           System.out.println("Expr -> Expr PLUS Expr");
           RESULT = new BinaryOpNode(e1, e2, "+");
       :}
       | Expr:e1 MINUS Expr:e2
       {: 
           System.out.println("Expr -> Expr MINUS Expr");
           RESULT = new BinaryOpNode(e1, e2, "-");
       :}
       | Expr:e1 MULTIPLY Expr:e2
       {: 
           System.out.println("Expr -> Expr MULTIPLY Expr");
           RESULT = new BinaryOpNode(e1, e2, "*");
       :}
       | Expr:e1 DIVIDE Expr:e2
       {: 
           System.out.println("Expr -> Expr DIVIDE Expr");
           RESULT = new BinaryOpNode(e1, e2, "/");
       :}
       | Expr:e1 LESS_THAN Expr:e2
       {: 
           System.out.println("Expr -> Expr LESS_THAN Expr");
           RESULT = new BinaryOpNode(e1, e2, "<");
       :}
       | Expr:e1 GREATER_THAN Expr:e2
       {: 
           System.out.println("Expr -> Expr GREATER_THAN Expr");
           RESULT = new BinaryOpNode(e1, e2, ">");
       :}
       | Expr:e1 LESS_THAN_EQUALS Expr:e2
       {: 
           System.out.println("Expr -> Expr LESS_THAN_EQUALS Expr");
           RESULT = new BinaryOpNode(e1, e2, "<=");
       :}
       | Expr:e1 GREATER_THAN_EQUALS Expr:e2
       {: 
           System.out.println("Expr -> Expr GREATER_THAN_EQUALS Expr");
           RESULT = new BinaryOpNode(e1, e2, ">=");
       :}
       | Expr:e1 EQUALS_EQUALS Expr:e2
       {: 
           System.out.println("Expr -> Expr EQUALS_EQUALS Expr");
           RESULT = new BinaryOpNode(e1, e2, "==");
       :}
       | Location:l EQUALS_EQUALS Literal:r
       {: 
           System.out.println("Expr -> Location EQUALS_EQUALS Literal");
           RESULT = new BinaryOpNode(l, r, "==");
       :}
       | Expr:e1 NOT_EQUALS Expr:e2
       {: 
           System.out.println("Expr -> Expr NOT_EQUALS Expr");
           RESULT = new BinaryOpNode(e1, e2, "!=");
       :}
       | Expr:e1 AND Expr:e2
       {: 
           System.out.println("Expr -> Expr AND Expr");
           RESULT = new BinaryOpNode(e1, e2, "&&");
       :}
       | Expr:e1 OR Expr:e2
       {: 
           System.out.println("Expr -> Expr OR Expr");
           RESULT = new BinaryOpNode(e1, e2, "||");
       :}
       | MINUS Expr:e
       {: 
           System.out.println("Expr -> MINUS Expr");
           RESULT = new UnaryOpNode(e, "-");
       :}
       | NOT Expr:e
       {: 
           System.out.println("Expr -> NOT Expr");
           RESULT = new UnaryOpNode(e, "NOT");
       :}
       | LPAREN Expr:e RPAREN
       {: 
           System.out.println("Expr -> ( Expr )");
           RESULT = new ParenExprNode(e);
       :}
       ;


Literal ::= NUMBER:n
           {: 
               System.out.println("Literal -> NUMBER");
               RESULT = new LiteralNode(String.valueOf(n)); 
           :}
         | TRUE
           {: 
               System.out.println("Literal -> TRUE");
               RESULT = new LiteralNode("true"); 
           :}
         | FALSE
           {: 
               System.out.println("Literal -> FALSE");
               RESULT = new LiteralNode("false"); 
           :}
         | STRINGLIT:s
           {: 
               System.out.println("Literal -> STRINGLIT");
               RESULT = new LiteralNode(s); 
           :}
         ;
